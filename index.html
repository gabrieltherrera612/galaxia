<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <title>Esfera con Halos y Palabras Animadas</title>
  <style>
    body { margin:0; overflow:hidden; background:#000; }
    canvas { display:block; }
  </style>
</head>
<body>
<script src="three.min.js"></script>
<script src="OrbitControls.js"></script>
<script>
const scene = new THREE.Scene();

// Alejar la cámara un poco más
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
camera.position.set(0, 7, 15);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);

// === Esfera central más pequeña ===
const sphereGeo = new THREE.SphereGeometry(1.2, 64, 64); // esfera más pequeña
const sphereMat = new THREE.MeshStandardMaterial({ color:0x111111, roughness:1 });
const sphere = new THREE.Mesh(sphereGeo, sphereMat);
scene.add(sphere);

// === Luz central ===
const pointLight = new THREE.PointLight(0xffdd88, 10, 300);
scene.add(pointLight);

// === Función para textura radial brillante ===
function createRadialTexture(colorStart, colorEnd){
  const size = 512;
  const canvas = document.createElement('canvas');
  canvas.width = size;
  canvas.height = size;
  const ctx = canvas.getContext('2d');
  const gradient = ctx.createRadialGradient(size/2, size/2, size/4, size/2, size/2, size/2);
  gradient.addColorStop(0, colorStart);
  gradient.addColorStop(0.5, colorEnd);
  gradient.addColorStop(1, "rgba(0,0,0,0)");
  ctx.fillStyle = gradient;
  ctx.fillRect(0,0,size,size);
  return new THREE.CanvasTexture(canvas);
}

// === Crear halo tipo nubosidad brillante ===
function createHalo(inner, outer, colorStart, colorEnd, layers=10){
  const group = new THREE.Group();
  for(let i=0;i<layers;i++){
    const geo = new THREE.RingGeometry(inner, outer, 256);
    const mat = new THREE.MeshBasicMaterial({
      map: createRadialTexture(colorStart, colorEnd),
      side: THREE.DoubleSide,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      opacity: 0.2 + i*0.1
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.rotation.x = Math.PI/2;
    mesh.scale.set(1 + i*0.02, 1 + i*0.02, 1);
    group.add(mesh);
  }
  return group;
}

// === Duplicar halos para intensidad ===
function createExtremeHalo(inner, outer, colorStart, colorEnd, duplicates=8){
  const group = new THREE.Group();
  for(let d=0; d<duplicates; d++){
    const halo = createHalo(inner, outer, colorStart, colorEnd);
    halo.children.forEach((c,i)=>{
      const factor = 1 + d*0.015 + i*0.01;
      c.scale.set(c.scale.x*factor, c.scale.y*factor, 1);
      c.material.opacity *= 0.6 + d*0.05;
    });
    group.add(halo);
  }
  return group;
}

// === Halos ajustados a la esfera más pequeña ===
const halo0 = createExtremeHalo(1.35, 1.75, "#ffffee", "#ffffdd");
const halo1 = createExtremeHalo(1.9, 2.1, "#ffffaa", "#ffffaa"); 
const halo2 = createExtremeHalo(2.1, 2.3, "#ffff88", "#ffff88");
const halo3 = createExtremeHalo(2.3, 2.5, "#ffdd66", "#ffdd66");
const halo4 = createExtremeHalo(2.5, 2.7, "#ffbb44", "#ffbb44");
const halo5 = createExtremeHalo(2.7, 2.9, "#ff8844", "#ff8844"); 
const halo6 = createExtremeHalo(2.9, 3.1, "#ff7733", "#ff7733"); 
const halo7 = createExtremeHalo(3.1, 3.3, "#ff5522", "#ff5522"); 

scene.add(halo0, halo1, halo2, halo3, halo4, halo5, halo6, halo7);

// === Estrellas de fondo ===
function createStars(num){
  const geo = new THREE.BufferGeometry();
  const positions = [];
  for(let i=0;i<num;i++){
    positions.push((Math.random()-0.5)*300);
    positions.push((Math.random()-0.5)*300);
    positions.push((Math.random()-0.5)*300);
  }
  geo.setAttribute('position', new THREE.Float32BufferAttribute(positions,3));
  const mat = new THREE.PointsMaterial({color:0xffffff,size:0.8,transparent:true});
  return new THREE.Points(geo,mat);
}
scene.add(createStars(2000));

// === Palabras flotantes con halo rosa claro y animación ===
const words = [
  "Mi Amor", "Cariño", "Eres lo mejor", "Gracias por todo", "Mi Alegría", 
  "Te amo", "Eres todo", "Mi vida", "Mi Corazón", "Ternura", 
  "Mi cielo", "Mi Amor eterno", "Eres única", "Dulzura","Eres especial",
  "Mi tesoro", "Amor mío", "Mi alegría", "Mi sol","Mi Amor infinito",
  "Mi cielo azul", "Mi vida hermosa", "Eres bella", "Mi mundo",
  "Mi estrella", "Mi inspiración", "Te adoro", "Mi corazón", "Eres mágica",
  "Amor eterno", "Cariño mío"
];

const wordSprites = [];

function createWordSprite(text, color="#ffb6c1", scale=1.5){ // rosa claro
  const canvas = document.createElement('canvas');
  canvas.width = 256;
  canvas.height = 64;
  const ctx = canvas.getContext('2d');
  ctx.font = "Bold 25px Arial"; 
  ctx.fillStyle = color;
  ctx.shadowColor = color;
  ctx.shadowBlur = 10;
  ctx.textAlign = "center";
  ctx.fillText(text, canvas.width/2, canvas.height/1.5);
  const texture = new THREE.CanvasTexture(canvas);
  const spriteMat = new THREE.SpriteMaterial({map:texture, transparent:true, blending:THREE.AdditiveBlending});
  const sprite = new THREE.Sprite(spriteMat);
  sprite.scale.set(scale, scale/2, 1);
  return sprite;
}

// Posicionar palabras alrededor de la esfera y animarlas
words.forEach((w)=>{
  const sprite = createWordSprite(w);
  const angle = Math.random() * Math.PI * 2;
  const radius = 6 + Math.random()*2; 
  sprite.userData = { angle, radius, speed:0.001 }; // muy lento
  sprite.position.set(Math.cos(angle)*radius, (Math.random()-0.5)*4, Math.sin(angle)*radius);
  wordSprites.push(sprite);
  scene.add(sprite);
});

// Luz ambiental
scene.add(new THREE.AmbientLight(0x404040,0.4));

// Animación
function animate(){
  requestAnimationFrame(animate);

  // Girar palabras lentamente alrededor de la esfera
  wordSprites.forEach(s=>{
    s.userData.angle += s.userData.speed;
    s.position.x = Math.cos(s.userData.angle) * s.userData.radius;
    s.position.z = Math.sin(s.userData.angle) * s.userData.radius;
  });

  controls.update();
  renderer.render(scene,camera);
}
animate();

// Ajuste responsive
window.addEventListener("resize", ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
